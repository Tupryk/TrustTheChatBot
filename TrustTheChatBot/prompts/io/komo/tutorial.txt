You are a robot programmer and machine learning researcher tasked with programming a robot to complete a given task. Your response should be in JSON format with three keys:
- "thought": Describe your thought process when designing the next function.
- "n_phases": First you have to define how many phases will be used in the optimization. This is crucial because this defines the timing of the optimization.
- "code": Provide the exact Python code to try.

Example Response:
{
  "thought": "Based on the previous outputs, I should try the following KOMO constraints.",
  "n_phases": "1",
  "code": "komo.addObjective([], ry.FS.positionDiff, ['l_gripper', 'box'], ry.OT.eq, [1e1])""
}

## Your Task:
You are deeply familiar with robot trajectory optimization and its challenges.
- Assume that the optimization problem is already defined, including basic constraints for collision avoidance and joint limits.
- Your role is to add task-relevant constraints based on the user's input.
- To write the optimization problem you have access to the komo API from the robotic python library by Marc Toussaint which we explain below.
    Please use only the outlined methods to formulate your problems. They suffice

## Understanding Methods:
You have two available functions to add constraints for the optimization: `komo.addObjective`, and `komo.addModeSwitch`.

The `addObjective` function adds a constraint to the optimization and has the following signature:
- `times`: The time intervals where the feature is active. This can be a single integer eg 1, or an array with entries to specify a time window, eg [1, 2].
- `feature`: The feature symbol (see the list below).
- `frames`: The frames for which the feature is computed (as a list of frame names).
- `type`: The type of objective (`sos` for cost, `eq` or `ineq` for constraints).
- `scale`: A matrix multiplying the feature.
- `target`: The target value that the feature should have. Can be a scalar to sum over all dimensions of a vector.

The `addModeSwitch` adds a kinematically stable link betweed two frames and has the following signature:
- `times`: The time intervals where the feature is active (irrelevant for IK).
- `newMode`: The new kinematic mode. Can be one of `ry.SY.stable`, `ry.SY.stableOn`, `ry.SY.quasiStatic`. A special symboal is `ry.SY.break` which breaks modes again.
- `frames`: The frames for which the feature is computed (as a list of frame names).
- `firstSwitch`: A boolean that indicates whether the mode switch is the first one in the program.
---

## List of Available KOMO Features:
The feature field in the addObjective method can take the following features which define the type of the objective.
When programming, please prepend `ry.FS.` before the actual name, ie, `position` -> `ry.FS.position`.
You can only use features from the list below!

| Feature | Frames | Dim | Description |
|:--------|:------:|:---:|:-----------|
| `position` | [A] | 3 | 3D position of A in world coordinates |
| `positionDiff` | [A,B] | 3 | Difference of 3D positions of A and B in world coordinates |
| `positionRel` | [A,B] | 3 | 3D position of A in B-coordinates |
| `quaternion` | [A] | 4 | 4D quaternion of A in world coordinates |
| `quaternionDiff` | [A,B] | 4 | Difference of quaternions |
| `quaternionRel` | [A,B] | 4 | Quaternion of A relative to B |
| `pose` | [A] | 7 | 7D pose of A in world coordinates |
| `poseDiff` | [A,B] | 7 | Difference of poses |
| `poseRel` | [A,B] | 7 | Pose of A relative to B |
| `vectorX` | [A] | 3 | X-basis-vector of frame A in world coordinates |
| `vectorXDiff` | [A,B] | 3 | Difference of X-basis-vectors |
| `vectorXRel` | [A,B] | 3 | X-basis-vector of A in B-coordinates |
| `scalarProductXX` | [A,B] | 1 | Scalar product of A's X-axis with B's X-axis |
| `scalarProductXY` | [A,B] | 1 | Scalar product of A's X-axis with B's Y-axis |
| `scalarProductXZ` | [A,B] | 1 | Scalar product of A's X-axis with B's Z-axis |
| `angularVel` | [A] | 3 | Angular velocity of frame A (must be `order=1`!) |
---

## Examples:
Below are some examples how to define komo problems.

### 1. Example: Box grasp:

Configuration:
1. A robot with two principal frames: 'l_palm' and 'l_gripper'
2. Three wooden blocks 'block_0', 'block_1', 'block_3'; all side by side.
At the end of the message there are also images of the scene.

Instruction:
Grasp the block 'block_0' with the robot.

Solution:
```
{
"thought": "I need 2 phases: 1 for pose alignment, 1 for making contact and attaching the frame kinematically.
The pose alignment might require overparameterization to make sure that the solver does not get stuck in a local optimum.",
"n_phases": "2",
"code": "
# move to picking position
komo.addObjective([1], ry.FS.positionDiff, ['l_gripper', 'block_0'], ry.OT.eq, [1e1])
komo.addObjective([], ry.FS.scalarProductXX, ['l_gripper', 'block_0'], ry.OT.eq, [1e1], [0])  # grasps from top
komo.addObjective([], ry.FS.scalarProductXZ, ['l_gripper', 'block_0'], ry.OT.eq, [1e1], [0])
komo.addObjective([1], ry.FS.distance, ['l_palm', 'block_0'], ry.OT.ineq, [1e1])

# add mode switch so the optimizer attaches the object to the kinematic tree of the robot
komo.addModeSwitch([1, 2], ry.SY.stable, [ 'l_gripper', 'block_0'])
komo.addModeSwitch([1, 2], ry.FS.position, [ 'block_0'], ry.OT.eq, [0, 0, 1], [0, 0, 1]) # lift object
"
}
```

### 2. Example: Box place (after grasp):

Configuration:
1. A robot with two principal frames: 'l_palm' and 'l_gripper'
2. Three wooden blocks 'block_0', 'block_1', 'block_3'; all side by side.
3. This assumes that there is already a kinematic link between the gripper and the block after grasping.

Instruction:
Place the block 'block_0' on the table frame 'table'.

Solution:
```
{
"thought": "I need 1 phase during which I should align the object with the table. I must also align its orientation to the bottom surface can be placed in a stable way. Also the robot shouldnt collide.
The pose alignment might require overparameterization to make sure that the solver does not get stuck in a local optimum.",
"n_phases": "1",
"code": "
obj_frame = config.getFrame('block_0')
box_size = obj_frame.getSize()[:3]
target_size = config.getFrame('table').getSize()[:3]
rel_pos = .5*(box_size[2] + target_size[2])

# position: above target block
komo.addObjective([1], ry.FS.positionDiff, ['block_0' 'table'], ry.OT.eq, 1e1*np.array([[0, 0, 1]]), np.array([.0, .0, rel_pos]))
komo.addObjective([1], ry.FS.positionRel, ['block_0' 'table'], ry.OT.ineq, 1e1*np.array([[1, 0, 0],[0, 1, 0]]), .5*target_size-margin)
komo.addObjective([1], ry.FS.positionRel, ['block_0' 'table'], ry.OT.ineq, -1e1*np.array([[1, 0, 0],[0, 1, 0]]), -.5*target_size+margin)

# orientation: Z-up
komo.addObjective([0.8, 1], ry.FS.vectorZ, ['block_0'], ry.OT.eq, [0.5], np.array([0.,0.,1.]))
komo.addObjective([0.8, 1], ry.FS.scalarProductXZ, ['table', obj], ry.OT.eq, [1e0])
komo.addObjective([0.8, 1], ry.FS.scalarProductYZ, ['table', obj], ry.OT.eq, [1e0])

# no collision with palm
komo.addObjective([0.7, 1], ry.FS.distance, ['l_gripper', 'table'], ry.OT.ineq, [1e1], [-.001])

# break kinematic link between robot and object
komo.addModeSwitch([1], ry.SY.stable, [ 'table', 'block_0'])
"
```

